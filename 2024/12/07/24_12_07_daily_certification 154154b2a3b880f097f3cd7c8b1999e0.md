# 24_12_07_daily_certification

```
[#342 koreii] 데일리인증 20241207
1. Operating System
1-1. Deadlock Avoidance Algorithm
	- Resource Allocation Graph Algorithm
	- Banker's Algorithm
2. 코딩 테스트 대비 알고리즘 학습
- Custom Sorting (LeetCode 179. Largest Number)
- DFS, Binary Tree, Height-Balanced (LeetCode 110. Balanced Binary Tree)
```

# Problem Solving (Algorithm & SQL)

### LeetCode **Largest Number**

[Largest Number - LeetCode](https://leetcode.com/problems/largest-number/description/)

```java
import java.util.Comparator;

class Solution {
    public String largestNumber(int[] nums) {
        StringBuilder sb = new StringBuilder();
        String[] numStrs = new String[nums.length];

        for(int i = 0; i < nums.length; i++)
            numStrs[i] = Integer.toString(nums[i]);
        
        Arrays.sort(numStrs, new Comparator<String>() {
            @Override
            public int compare(String str1, String str2) {
                String lr = str1 + str2;
                String rl = str2 + str1;
                
                if(lr.compareTo(rl) < 0)   //  lr이 rl보다 큰 경우 ex) str1 = 3, str2 = 30 -> lr = 330, rl = 303
                    return 1;  //  str1이 먼저 나와야 함
                else
                    return -1;   //  str2가 먼저 나와야 함
            }
        });

        for(String num : numStrs)
            sb.append(num);

        String answer = sb.toString();

        boolean all0 = true;
        for(int i = 0; i < answer.length(); i++) {
            if(answer.charAt(i) != '0') {
                all0 = false;
                break;
            }
        }

        return all0 ? "0" : answer;
    }
}
```

### LeetCode **Balanced Binary Tree**

[Balanced Binary Tree - LeetCode](https://leetcode.com/problems/balanced-binary-tree/description/)

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    private boolean balanced = true;

    public boolean isBalanced(TreeNode root) {
        dfs(root);

        return balanced;
    }

    //  root의 높이 반환
    private int dfs(TreeNode root) {
        if(root == null)    //  노드가 없을 경우 높이 -1로 간주
            return -1;

        int lh = dfs(root.left);
        int rh = dfs(root.right);

        if(Math.abs(lh - rh) > 1)
            balanced = false;

        return Math.max(lh, rh) + 1;
    }
}
```