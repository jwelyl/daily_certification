# 24_01_14_daily_certification

```
[koreii] #14 데일리인증
20240114
알고리즘
- 트리의 지름을 활용 & 테스트케이스 별로 초기화하는 문제 + 난이도 ㅣㄱ여
```

# Problem Solving (Algorithm & SQL)

**BOJ 3482 Labyrinth**

[3482번: Labyrinth](https://www.acmicpc.net/problem/3482)

문제를 번역하면 어떤 두 빈 칸 사이에는 반드시 경로가 존재하고, 경로는 반드시 하나라고 되어 있다. 이를 통해 트리 구조임을 알 수 있다.(있어야 한다.)

두 빈 칸 사이를 잇는 가장 긴 줄의 길이를 찾는 문제이므로 트리의 지름 문제임을 알 수 있다.

기존에 해결했던 트리 지름 문제와 다른 점은 인접 리스트 형태 그래프가 아니라 격자 형태 그래프라서 root를 정하는 방식이 조금 달랐고 여러 테스트케이스를 한번에 해결하는 문제이므로 매번 테스트케이스때마다 전역변수들을 모두 초기화해줘야 했다. 그러지 않으면 ArrayOutOfBounds Exception이 발생한다. 

무작정 전역 변수를 사용하는 것의 위험성을 알 수 있었다. 

**코드**

```kotlin
import java.util.*
import java.io.*

class BOJ_3482 {
    private val br = BufferedReader(InputStreamReader(System.`in`))
    private val sb = StringBuilder()
    private lateinit var tokens: StringTokenizer

    private var t = 0
    private var row = 0
    private var col = 0
    private lateinit var map : Array<CharArray>
    private lateinit var visited : Array<BooleanArray>
    private var rootY = -1
    private var rootX = -1
    private var farthestY = 0
    private var farthestX = 0
    private var diameter = 0

    fun solve() {
        t = br.readLine().toInt()

        repeat(t) {
            tokens = StringTokenizer(br.readLine())
            col = tokens.nextToken().toInt()
            row = tokens.nextToken().toInt()

            rootY = -1
            rootX = -1
            diameter = 0

            map = Array(row) { CharArray(col) }
            visited = Array(row) { BooleanArray(col) }

            for(i in 0 ..< row) {
                map[i] = br.readLine().toCharArray()
                for(j in 0 ..< col) {
                    if(map[i][j] == '.' && rootY == -1 && rootX == -1) {
                        rootY = i
                        rootX = j
                    }
                }
            }

            if(rootY != -1 && rootX != -1) {
                dfs(rootY, rootX, 0)

                for (i in 0..< row)
                    Arrays.fill(visited[i], false)

                diameter = 0
                rootY = farthestY
                rootX = farthestX

                dfs(rootY, rootX, 0)
            }

            sb.append("Maximum rope length is $diameter.\n")
        }

        print(sb)
    }

    private val dy = intArrayOf(0, 1, 0, -1)
    private val dx = intArrayOf(1, 0, -1, 0)

    private fun isIn(y : Int, x : Int) : Boolean {
        return y in 0 ..< row && x in 0 ..< col
    }

    private fun dfs(y : Int, x : Int, dist : Int) {
        visited[y][x] = true

        if(dist > diameter) {
            diameter = dist
            farthestY = y
            farthestX = x
        }

        for(d in 0 ..< 4) {
            val ny = y + dy[d]
            val nx = x + dx[d]

            if(isIn(ny, nx) && map[ny][nx] == '.' && !visited[ny][nx])
                dfs(ny, nx, dist + 1)
        }
    }
}

fun main() {
    BOJ_3482().solve()
}
```